name: Automated Multi-Agent Peer Review

# This workflow implements automated sequential peer review using LLM APIs.
#
# MANUAL TRIGGER ONLY - Saves API costs by running only when you click "Run workflow"
#
# Flow:
# 1. Manually trigger workflow and enter PR number
# 2. Agents review sequentially based on PR author
# 3. Reviews posted with inline comments
# 4. If 2+ approvals â†’ Mark PR as peer-review:approved
#
# Requirements:
# - LLM_API_KEY secret must be configured in repository
# - Supports: Anthropic, OpenAI, or other providers (configure in .llm/config.json)

on:
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to review'
        required: true
        type: number

permissions:
  pull-requests: write
  issues: write
  contents: read

jobs:
  sequential-peer-review:
    name: Sequential Multi-Agent Review
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Install dependencies
        run: |
          cd .github/scripts
          npm install

      - name: Determine Reviewers
        id: reviewers
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = ${{ inputs.pr_number }};

            // Get PR details
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });

            const branchName = pr.data.head.ref;
            // Generic pattern: {llm-agent-name}/{agent-type}-{project}-{sessionID}
            // Examples: copilot/developer-sudoku-webapp-123, claude/architect-app-456, gemini/tester-web-789
            // Agent types are known: developer, architect, tester, it, product-owner
            // Project name can contain hyphens, sessionID is numeric at the end
            const branchPattern = /^([a-z-]+)\/(developer|architect|tester|it|product-owner)-(.+)-(\d+)$/;
            const match = branchName.match(branchPattern);

            if (!match) {
              console.log(`Branch "${branchName}" does not match expected pattern. Expected: {llm-name}/{agent-type}-{project}-{sessionID}`);
              console.log(`Valid agent types: developer, architect, tester, it, product-owner`);
              core.setOutput('skip', 'true');
              return;
            }

            const llmAgentName = match[1];  // e.g., "copilot", "claude", "gemini"
            const agentType = match[2];     // e.g., "developer", "architect", "tester"
            const projectName = match[3];   // e.g., "sudoku-webapp", "app"
            const sessionId = match[4];     // e.g., "1769889815"
            
            console.log(`LLM Agent: ${llmAgentName}, Agent Type: ${agentType}, Project: ${projectName}, Session: ${sessionId}`);

            // Define review assignment rules (reduced reviewers to save costs)
            const reviewRules = {
              'developer': ['architect', 'tester'],           // 2 reviewers
              'architect': ['developer', 'tester'],           // 2 reviewers
              'tester': ['developer', 'product-owner'],       // 2 reviewers
              'it': ['architect'],                            // 1 reviewer
              'product-owner': ['architect']                  // 1 reviewer
            };

            const reviewers = reviewRules[agentType] || [];
            console.log(`Agent: ${agentType}, Reviewers: ${reviewers.join(', ')}`);

            core.setOutput('agent_type', agentType);
            core.setOutput('reviewers', JSON.stringify(reviewers));
            core.setOutput('skip', 'false');
            core.setOutput('pr_number', prNumber);

      - name: Get PR Details
        id: pr_details
        if: steps.reviewers.outputs.skip != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = ${{ inputs.pr_number }};

            // Get PR diff
            const diff = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
              mediaType: {
                format: 'diff'
              }
            });

            // Get changed files
            const files = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });

            // Get PR info
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });

            // Store PR details
            const prDetails = {
              number: prNumber,
              title: pr.data.title,
              body: pr.data.body || '',
              diff: diff.data,
              files: files.data.map(f => ({
                filename: f.filename,
                status: f.status,
                additions: f.additions,
                deletions: f.deletions,
                changes: f.changes,
                patch: f.patch || ''
              }))
            };

            // Write to file for next step
            const fs = require('fs');
            fs.writeFileSync('pr_details.json', JSON.stringify(prDetails, null, 2));

            return prDetails;

      - name: Run Sequential Agent Reviews
        id: run_reviews
        if: steps.reviewers.outputs.skip != 'true'
        env:
          LLM_API_KEY: ${{ secrets.LLM_API_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Parse reviewers list
          REVIEWERS='${{ steps.reviewers.outputs.reviewers }}'
          echo "Reviewers to run: $REVIEWERS"
          
          # Convert JSON array to bash array
          REVIEWER_LIST=$(echo $REVIEWERS | jq -r '.[]')
          
          # Loop through each reviewer agent
          for agent in $REVIEWER_LIST; do
            echo "================================================"
            echo "Running review as: $agent"
            echo "================================================"
            
            node .github/scripts/automated-review.js \
              --agent "$agent" \
              --pr-number "${{ inputs.pr_number }}" \
              --repo "${{ github.repository }}" \
              --pr-details-file "pr_details.json"
            
            review_exit_code=$?
            
            if [ $review_exit_code -ne 0 ]; then
              echo "âš ï¸  Review by $agent encountered an error (exit code: $review_exit_code)"
            else
              echo "âœ… Review by $agent completed successfully"
            fi
            
            echo ""
          done
          
          echo "All reviews completed!"

      - name: Check Approval Status
        id: approval_status
        if: steps.reviewers.outputs.skip != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = ${{ inputs.pr_number }};

            // Get all review comments with "APPROVE" or "REQUEST_CHANGES" markers
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber
            });

            // Count approvals from this workflow run
            let approvals = 0;
            let changesRequested = 0;

            // Generic marker for any agent review
            const agentReviewPattern = /\*\*(.+?) Agent Review\*\*/;

            for (const comment of comments.data) {
              const body = comment.body;

              // Check if this is an agent review comment (generic pattern)
              const isAgentReview = agentReviewPattern.test(body);

              if (isAgentReview) {
                if (body.includes('âœ… **APPROVED**')) {
                  approvals++;
                } else if (body.includes('ðŸ”´ **CHANGES REQUESTED**')) {
                  changesRequested++;
                }
              }
            }

            console.log(`Approvals: ${approvals}, Changes Requested: ${changesRequested}`);

            // Get number of reviewers assigned to determine required approvals
            const agentType = '${{ steps.reviewers.outputs.agent_type }}';
            const reviewers = JSON.parse('${{ steps.reviewers.outputs.reviewers }}');
            const requiredApprovals = reviewers.length; // All reviewers must approve

            console.log(`Required approvals: ${requiredApprovals} (all ${reviewers.length} reviewers)`);

            if (approvals >= requiredApprovals && changesRequested === 0) {
              // Mark as peer-review approved
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                labels: ['peer-review:approved', 'ready-for-user-review']
              });

              // Remove awaiting-review labels
              const currentLabels = await github.rest.issues.listLabelsOnIssue({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber
              });

              for (const label of currentLabels.data) {
                if (label.name.startsWith('awaiting-')) {
                  await github.rest.issues.removeLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: prNumber,
                    name: label.name
                  }).catch(() => {}); // Ignore errors
                }
              }

              // Post approval summary comment
              const reviewersList = reviewers.map(r => r.charAt(0).toUpperCase() + r.slice(1)).join(', ');
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: `## âœ… Peer Review Approved\n\n**${approvals}/${requiredApprovals}** required approvals obtained!\n\nâœ¨ This PR has passed all peer reviews and is **ready for user review and merge**.\n\n**Reviewers:** ${reviewersList}\n\n---\n*Automated peer review by multi-agent system*`
              });

              console.log('âœ… PR approved by peers!');

            } else if (changesRequested > 0) {
              // Mark as changes requested
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                labels: ['peer-review:changes-requested']
              });

              console.log('ðŸ”´ Changes requested by reviewers');

            } else {
              console.log(`â³ Waiting for approvals: ${approvals}/${requiredApprovals}`);
            }

            return {
              approvals,
              changesRequested,
              approved: approvals >= requiredApprovals && changesRequested === 0
            };

      - name: Summary
        if: steps.reviewers.outputs.skip != 'true'
        run: |
          echo "## ðŸ¤– Automated Peer Review Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Sequential reviews completed by:" >> $GITHUB_STEP_SUMMARY
          echo "${{ steps.reviewers.outputs.reviewers }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Check PR comments for detailed review feedback from each agent." >> $GITHUB_STEP_SUMMARY
